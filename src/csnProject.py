import csnUtility
import csnDependencies
import csnProjectPaths
import csnInstall
import csnCompile
import csnTests
import inspect
import os.path
import glob
import types
import GlobDirectoryWalker
import OrderedSet
import unittest

globalCurrentContext = None

def Project(_name, _type, _sourceRootFolder = None, _categories = None):
    if _sourceRootFolder is None:
        _sourceRootFolder = csnUtility.NormalizePath(os.path.dirname(inspect.stack()[1][1]))
    return globalCurrentContext.CreateProject(_name, _type, _sourceRootFolder, _categories)

def Dll(_name, _sourceRootFolder = None, _categories = None):
    if _sourceRootFolder is None:
        _sourceRootFolder = csnUtility.NormalizePath(os.path.dirname(inspect.stack()[1][1]))
    return Project(_name, "dll", _sourceRootFolder, _categories)

def Library(_name, _sourceRootFolder = None, _categories = None):
    if _sourceRootFolder is None:
        _sourceRootFolder = csnUtility.NormalizePath(os.path.dirname(inspect.stack()[1][1]))
    return Project(_name, "library", _sourceRootFolder, _categories)

class Rule:
    """ This class contains a build rule for e.g. Visual Studio, Make, etc """
    def __init__(self):
        self.workingDirectory = ""
        self.command = ""

def ToProject(project):
    """
    Helper function that tests if its argument (project) is a function. If so, it returns the result of the function. 
    If not, it returns its argument (project). It is used to treat Project instances and functions returning a Project instance
    in the same way.
    """
    result = project
    if type(project) == types.FunctionType:
        result = project()
    return result

class GenericProject(object):
    """
    The constructors initialises these member variables:
    self.buildSubFolder -- Direct subfolder - within the build folder - for this project. Is either 'executable' or 'library'.
    self.installSubfolder -- Direct subfolder - within the install folder - for targets generated by this project.
    self.useBefore -- A list of projects. The use-file of this project must be included before the use-file of the projects in this list.
    self.configFilePath -- Path to the config file for the project.
    self.sources -- Sources to be compiled for this target.
    self.sourceGroups -- Dictionary (groupName -> sources) for sources that should be placed in a visual studio group.
    self.rules - CMake rules. See AddRule function.
    self.sourcesToBeMoced -- Sources for which a qt moc file must be generated.
    self.sourcesToBeUIed -- Sources for which qt's UI.exe must be run.
    self.filesToInstall -- Contains files to be installed in the binary folder. It has the structure filesToInstall[mode][installPath] = files.
    For example: if self.filesToInstall[\"Debug\"][\"data\"] = [\"c:/one.txt\", \"c:/two.txt\"], 
    then c:/one.txt and c:/two.txt must be installed in the data subfolder of the install folder when in debug mode.
    self.useFilePath -- Path to the use file of the project. If it is relative, then the build folder will be prepended.
    self.cmakeListsSubpath -- Path to the cmake file (relative to the build folder) that builds this project.
    self.projects -- Set of related project instances. These projects have been added to self using AddProjects.
    self.projectsNonRequired -- Subset of self.projects. Contains projects that self doesn't depend on.
    The project does not add a dependency on any project in this list.      
    self.generateWin32Header -- Flag that says if a standard Win32Header.h must be generated
    self.precompiledHeader -- Name of the precompiled header file. If non-empty, and using Visual Studio (on Windows),
    then precompiled headers are used for this project.
    self.customCommands -- List of extra commands that must be run when configuring this project.
    """
    
    def __init__(self, _name, _type, _sourceRootFolder = None, _categories = None, _context = None):
        """
        _type -- Type of the project, should be \"executable\", \"library\", \"dll\" or \"third party\".
        _name -- Name of the project, e.g. \"SampleApp\".
        _sourceRootFolder -- Folder used for locating source files for this project. If None, then the folder name is derived from 
        the call stack. For example, if this class' constructor is called in a file d:/users/me/csnMyProject.py, then d:/users/me 
        will be set as the source root folder.
        """    
        self.context = _context
        self.name = _name
        self.type = _type
        if _sourceRootFolder is None:
            _sourceRootFolder = csnUtility.NormalizePath(os.path.dirname(inspect.stack()[1][1]))
        self.pathsManager = csnProjectPaths.Manager(self, _sourceRootFolder)
            
        self.installManager = csnInstall.Manager(self)
        self.rules = dict()
        self.customCommands = []
        self.categories = _categories
        if self.categories is None:
            self.categories = []
        self.dependenciesManager = csnDependencies.Manager(self)
        self.compileManager = csnCompile.Manager(self)
        self.installSubFolder = ""
        self.testsManager = csnTests.Manager(self)
        
    def AddProjects(self, _projects, _dependency = True): 
        self.dependenciesManager.AddProjects(_projects, _dependency)

    def AddSources(self, _listOfSourceFiles, _moc = 0, _ui = 0, _sourceGroup = "", _checkExists = 1, _forceAdd = 0):
        self.compileManager.AddSources(_listOfSourceFiles, _moc, _ui, _sourceGroup, _checkExists, _forceAdd)
                   
    def RemoveSources(self, _listOfSourceFiles):
        self.compileManager.RemoveSources(_listOfSourceFiles)
                            
    def AddDefinitions(self, _listOfDefinitions, _private = 0, _WIN32 = 0, _NOT_WIN32 = 0 ):
        self.compileManager.AddDefinitions(_listOfDefinitions, _private, _WIN32, _NOT_WIN32)
        
    def AddFilesToInstall(self, _list, _location = None, _debugOnly = 0, _releaseOnly = 0, _WIN32 = 0, _NOT_WIN32 = 0):
        self.installManager.AddFilesToInstall(_list, _location, _debugOnly, _releaseOnly, _WIN32, _NOT_WIN32)
                
    def AddIncludeFolders(self, _listOfIncludeFolders, _WIN32 = 0, _NOT_WIN32 = 0):
        self.compileManager.AddIncludeFolders(_listOfIncludeFolders, _WIN32, _NOT_WIN32)
        
    def SetPrecompiledHeader(self, _precompiledHeader):
        self.compileManager.SetPrecompiledHeader(_precompiledHeader)
        
    def AddLibraryFolders(self, _listOfLibraryFolders, _WIN32 = 0, _NOT_WIN32 = 0):
        self.compileManager.AddLibraryFolders(_listOfLibraryFolders, _WIN32, _NOT_WIN32)
        
    def AddLibraries(self, _listOfLibraries, _WIN32 = 0, _NOT_WIN32 = 0, _debugOnly = 0, _releaseOnly = 0):
        self.compileManager.AddLibraries(_listOfLibraries, _WIN32, _NOT_WIN32, _debugOnly, _releaseOnly)
        
    def Glob(self, _path):
        return self.pathsManager.Glob(_path)
    
    def DependsOn(self, _otherProject, _skipList = None):
        return self.dependenciesManager.DependsOn(_otherProject, _skipList)
        
    def GetProjects(self, _recursive = 0, _onlyRequiredProjects = 0, _includeSelf = False, _onlyPublicDependencies = False, _onlyNonRequiredProjects = False, _skipList = None):
        return self.dependenciesManager.GetProjects(_recursive, _onlyRequiredProjects, _includeSelf, _onlyPublicDependencies, _onlyNonRequiredProjects, _skipList)
        
    def UseBefore(self, _otherProject):
        self.dependenciesManager.UseBefore(_otherProject)

    def WantsToBeUsedBefore(self, _otherProject):
        # remove from this interface
        return self.dependenciesManager.WantsToBeUsedBefore(_otherProject)
           
    def ProjectsToUse(self):
        # remove from this interface
        return self.dependenciesManager.ProjectsToUse()

    def GetPathToUseFile(self):
        # remove from this interface
        return self.pathsManager.GetPathToUseFile()

    def GetPathToConfigFile(self, _public):
        # remove from this interface
        return self.pathsManager.GetPathToConfigFile(_public)
            
    def ResolvePathsOfFilesToInstall(self, _skipCVS = 1):
        # remove from this interface
        self.installManager.ResolvePathsOfFilesToInstall(_skipCVS)
    
    def AddRule(self, description, command, workingDirectory = "."):
        """
        Adds a new rule to the self.rules dictionary, using description as the key.
        """
        rule = Rule()
        rule.command = command
        rule.workingDirectory = workingDirectory
        self.rules[description] = rule

    def AddCustomCommand(self, command):
        """ 
        Adds command to the list of custom commands. Each command must accept this instance (self) as the one and only argument. 
        For example:
        
        project.AddCustomCommand(project.DoSomethingSpecial)
        
        (... in class of project)
        def DoSomethingSpecial(self):
            # do special stuff
            pass
            
        """
        self.customCommands.append(command)

    def RunCustomCommands(self):
        """ Runs commands in self.customCommands, passing self as the one and only argument. """
        for command in self.customCommands:
            command(self)
            
    def AddTests(self, _listOfTests, _cxxTestProject, _enableWxWidgets = 0, _dependencies = None):
        self.testsManager.AddTests(_listOfTests, _cxxTestProject, _enableWxWidgets, _dependencies)

    def GetBuildFolder(self):
        return self.pathsManager.GetBuildFolder()

    def WriteDependencyStructureToXML(self, filename):
        # remove from this interface
        self.dependenciesManager.WriteDependencyStructureToXML(filename)

    def GetBinaryInstallFolder(self, _configurationName = "${CMAKE_CFG_INTDIR}"):
        return self.pathsManager.GetBinaryInstallFolder(_configurationName)

    def GetCMakeListsFilename(self):
        """ Return the filename for the CMakeLists.txt file for this project. """
        return "%s/%s" % (self.context.buildFolder, self.pathsManager.cmakeListsSubpath)

    def GenerateWin32Header(self):
        # remove from this interface
        self.compileManager.GenerateWin32Header()

    def GetConfig(self, _isPrivate):
        if _isPrivate:
            return self.compileManager.private
        else:
            return self.compileManager.public

    def GetPostProcessor(self):
        return self.postProcessor    

    def GetSources(self):
        return self.compileManager.sources
        
    def GetSourceRootFolder(self):
        return self.pathsManager.GetSourceRootFolder()

    def GetUseFilePath(self):
        # remove from this interface
        return self.pathsManager.useFilePath
        
    def SetUseFilePath(self, x):
        # remove from this interface
        self.pathsManager.useFilePath = x

    def GetConfigFilePath(self):
        # remove from this interface
        return self.pathsManager.configFilePath
        
    def SetConfigFilePath(self, x):
        # remove from this interface
        self.pathsManager.configFilePath = x
        
    def SetGenerateWin32Header(self, _flag):
        # remove from this interface
        """ If _flag, then the Win32Header is generated for this project. """
        self.compileManager.generateWin32Header = _flag

    def GetGenerateWin32Header(self):
        # remove from this interface
        """ See SetGenerateWin32Header """
        return self.compileManager.generateWin32Header
        
    def GetTestProject(self):
        return self.testsManager.testProject
        
    def MatchesFilter(self):
        for pattern in self.context.filter:
            for string in self.categories:
                if csnUtility.Matches(string, pattern):
                    return True
        return False

    useFilePath = property(GetUseFilePath, SetUseFilePath)
    configFilePath = property(GetConfigFilePath, SetConfigFilePath)
    generateWin32Header = property(GetGenerateWin32Header, SetGenerateWin32Header)
    testProject = property(GetTestProject)
    sourceRootFolder = property(GetSourceRootFolder)
    
class ProjectTest(unittest.TestCase):
    def testAddFilesToInstallWindows(self):
        location = "./Install"
        project = Project("TestProject", "dll")
        project.AddFilesToInstall(["Hello.cpp"], location, _WIN32 = 1)
        project.AddFilesToInstall(["Bye.h"], location, _NOT_WIN32 = 1)
        assert project.filesToInstall["Release"][location] == ["Hello.cpp"]
        assert project.filesToInstall["Debug"][location] == ["Hello.cpp"]
        
    def testAddFilesToInstallLinux(self):
        location = "./Install"
        project = Project("TestProject", "dll")
        project.AddFilesToInstall(["Hello.cpp"], location, _WIN32 = 1)
        project.AddFilesToInstall(["Bye.h"], location, _NOT_WIN32 = 1)
        assert project.filesToInstall["Release"][location] == ["Bye.h"]
        assert project.filesToInstall["Debug"][location] == ["Bye.h"]
    
if __name__ == "__main__":
    unittest.main() 
